{% assign rule_description = "Security guidelines, authentication patterns, and data protection standards for {{PROJECT_NAME}}" %}
{% assign globs = "**/auth/**, **/middleware/**, **/security/**, **/*auth*.ts, **/*security*.ts" %}
{% assign alwaysApply = false %}

{% comment %} Template Variables {% endcomment %}
{% assign PROJECT_NAME = PROJECT_NAME | default: "MyProject" %}

{% layout "layout/cursor.mdc.liquid" %}

{% block content %}
# {{PROJECT_NAME}} Security Standards

## Security Principles

- **Defense in Depth**: Multiple layers of security controls
- **Least Privilege**: Grant minimum necessary permissions
- **Zero Trust**: Verify everything, trust nothing
- **Secure by Default**: Make secure choices the default
- **Privacy by Design**: Built-in privacy protection

## Authentication

### JWT Implementation
```typescript
// lib/auth/jwt.ts
import jwt from 'jsonwebtoken';
import { z } from 'zod';

const JWT_SECRET = process.env.JWT_SECRET!;
const JWT_EXPIRES_IN = process.env.JWT_EXPIRES_IN || '7d';
const JWT_REFRESH_EXPIRES_IN = process.env.JWT_REFRESH_EXPIRES_IN || '30d';

export interface TokenPayload {
  userId: string;
  email: string;
  role: string;
  permissions: string[];
  iat?: number;
  exp?: number;
}

export const generateTokens = (payload: Omit<TokenPayload, 'iat' | 'exp'>) => {
  const accessToken = jwt.sign(payload, JWT_SECRET, {
    expiresIn: JWT_EXPIRES_IN,
    issuer: '{{PROJECT_NAME}}',
    audience: 'api'
  });

  const refreshToken = jwt.sign(
    { userId: payload.userId, type: 'refresh' },
    JWT_SECRET,
    {
      expiresIn: JWT_REFRESH_EXPIRES_IN,
      issuer: '{{PROJECT_NAME}}',
      audience: 'refresh'
    }
  );

  return { accessToken, refreshToken };
};

export const verifyToken = (token: string): TokenPayload => {
  try {
    return jwt.verify(token, JWT_SECRET, {
      issuer: '{{PROJECT_NAME}}',
      audience: 'api'
    }) as TokenPayload;
  } catch (error) {
    throw new Error('Invalid or expired token');
  }
};

export const verifyRefreshToken = (token: string) => {
  try {
    return jwt.verify(token, JWT_SECRET, {
      issuer: '{{PROJECT_NAME}}',
      audience: 'refresh'
    }) as { userId: string; type: string };
  } catch (error) {
    throw new Error('Invalid or expired refresh token');
  }
};
```

### Password Security
```typescript
// lib/auth/password.ts
import bcrypt from 'bcrypt';
import zxcvbn from 'zxcvbn';

const SALT_ROUNDS = 12;
const MIN_PASSWORD_STRENGTH = 3; // 0-4 scale

export const hashPassword = async (password: string): Promise<string> => {
  // Validate password strength
  const strength = zxcvbn(password);
  if (strength.score < MIN_PASSWORD_STRENGTH) {
    throw new Error(`Password too weak: ${strength.feedback.warning}`);
  }

  return bcrypt.hash(password, SALT_ROUNDS);
};

export const verifyPassword = async (password: string, hash: string): Promise<boolean> => {
  return bcrypt.compare(password, hash);
};

// Password validation schema
export const PasswordSchema = z.string()
  .min(8, 'Password must be at least 8 characters')
  .max(128, 'Password must not exceed 128 characters')
  .refine((password) => {
    const strength = zxcvbn(password);
    return strength.score >= MIN_PASSWORD_STRENGTH;
  }, {
    message: 'Password is too weak. Use a mix of letters, numbers, and symbols.'
  });
```

### Authentication Middleware
```typescript
// middleware/auth.ts
import { Request, Response, NextFunction } from 'express';
import { verifyToken, TokenPayload } from '../lib/auth/jwt';
import { UserRepository } from '../repositories/UserRepository';

export interface AuthenticatedRequest extends Request {
  user: TokenPayload;
}

export const authenticate = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const authHeader = req.headers.authorization;
    
    if (!authHeader?.startsWith('Bearer ')) {
      return res.status(401).json({
        error: 'Authentication required',
        code: 'MISSING_TOKEN'
      });
    }

    const token = authHeader.slice(7);
    const payload = verifyToken(token);

    // Verify user still exists and is active
    const user = await UserRepository.findById(payload.userId);
    if (!user || !user.isActive) {
      return res.status(401).json({
        error: 'Invalid or expired token',
        code: 'INVALID_TOKEN'
      });
    }

    (req as AuthenticatedRequest).user = payload;
    next();
  } catch (error) {
    return res.status(401).json({
      error: 'Invalid or expired token',
      code: 'INVALID_TOKEN'
    });
  }
};

export const requirePermissions = (requiredPermissions: string[]) => {
  return (req: Request, res: Response, next: NextFunction) => {
    const user = (req as AuthenticatedRequest).user;
    
    const hasPermission = requiredPermissions.some(permission =>
      user.permissions.includes(permission) || user.role === 'admin'
    );

    if (!hasPermission) {
      return res.status(403).json({
        error: 'Insufficient permissions',
        code: 'FORBIDDEN',
        required: requiredPermissions
      });
    }

    next();
  };
};

// Rate limiting for auth endpoints
import rateLimit from 'express-rate-limit';

export const authRateLimit = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 5, // 5 attempts per window
  message: {
    error: 'Too many authentication attempts',
    code: 'RATE_LIMITED',
    retryAfter: '15 minutes'
  },
  standardHeaders: true,
  legacyHeaders: false,
});
```

## Authorization

### Role-Based Access Control (RBAC)
```typescript
// lib/auth/permissions.ts
export const Permissions = {
  // User management
  USER_READ: 'user:read',
  USER_WRITE: 'user:write',
  USER_DELETE: 'user:delete',
  
  // Order management
  ORDER_READ: 'order:read',
  ORDER_WRITE: 'order:write',
  ORDER_DELETE: 'order:delete',
  
  // Admin functions
  ADMIN_PANEL: 'admin:panel',
  SYSTEM_CONFIG: 'system:config',
} as const;

export const Roles = {
  ADMIN: 'admin',
  MANAGER: 'manager',
  USER: 'user',
} as const;

export const RolePermissions = {
  [Roles.ADMIN]: Object.values(Permissions),
  [Roles.MANAGER]: [
    Permissions.USER_READ,
    Permissions.USER_WRITE,
    Permissions.ORDER_READ,
    Permissions.ORDER_WRITE,
  ],
  [Roles.USER]: [
    Permissions.ORDER_READ,
  ],
} as const;

export const hasPermission = (userPermissions: string[], required: string): boolean => {
  return userPermissions.includes(required);
};

export const hasAnyPermission = (userPermissions: string[], required: string[]): boolean => {
  return required.some(permission => userPermissions.includes(permission));
};
```

### Resource-Based Authorization
```typescript
// middleware/resourceAuth.ts
export const requireResourceOwnership = (resourceType: 'user' | 'order') => {
  return async (req: Request, res: Response, next: NextFunction) => {
    const user = (req as AuthenticatedRequest).user;
    const resourceId = req.params.id;

    // Admins can access any resource
    if (user.role === 'admin') {
      return next();
    }

    try {
      let hasAccess = false;

      switch (resourceType) {
        case 'user':
          hasAccess = user.userId === resourceId;
          break;
        case 'order':
          const order = await OrderRepository.findById(resourceId);
          hasAccess = order?.userId === user.userId;
          break;
      }

      if (!hasAccess) {
        return res.status(403).json({
          error: 'Access denied to this resource',
          code: 'RESOURCE_FORBIDDEN'
        });
      }

      next();
    } catch (error) {
      return res.status(500).json({
        error: 'Failed to verify resource access',
        code: 'AUTHORIZATION_ERROR'
      });
    }
  };
};
```

## Data Protection

### Input Validation and Sanitization
```typescript
// middleware/validation.ts
import { z } from 'zod';
import DOMPurify from 'isomorphic-dompurify';
import { Request, Response, NextFunction } from 'express';

export const validateBody = <T>(schema: z.ZodSchema<T>) => {
  return (req: Request, res: Response, next: NextFunction) => {
    try {
      // Sanitize string inputs
      req.body = sanitizeObject(req.body);
      
      // Validate against schema
      const validatedData = schema.parse(req.body);
      req.body = validatedData;
      
      next();
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(422).json({
          error: 'Validation Error',
          code: 'VALIDATION_ERROR',
          details: error.errors
        });
      }
      next(error);
    }
  };
};

const sanitizeObject = (obj: any): any => {
  if (typeof obj === 'string') {
    return DOMPurify.sanitize(obj, { ALLOWED_TAGS: [] });
  }
  
  if (Array.isArray(obj)) {
    return obj.map(sanitizeObject);
  }
  
  if (obj && typeof obj === 'object') {
    const sanitized: any = {};
    for (const [key, value] of Object.entries(obj)) {
      sanitized[key] = sanitizeObject(value);
    }
    return sanitized;
  }
  
  return obj;
};
```

### SQL Injection Prevention
```typescript
// ✅ DO: Use parameterized queries
const getUserByEmail = async (email: string) => {
  return await db
    .select()
    .from(users)
    .where(eq(users.email, email)); // Parameterized
};

// ✅ DO: Use prepared statements
const getUserByIdPrepared = db
  .select()
  .from(users)
  .where(eq(users.id, placeholder('id')))
  .prepare();

// ❌ DON'T: String concatenation
const getUserByEmailUnsafe = async (email: string) => {
  return await db.execute(sql`
    SELECT * FROM users WHERE email = '${email}'
  `); // Vulnerable to SQL injection
};
```

### XSS Protection
```typescript
// middleware/security.ts
import helmet from 'helmet';
import { Request, Response, NextFunction } from 'express';

export const securityHeaders = helmet({
  contentSecurityPolicy: {
    directives: {
      defaultSrc: ["'self'"],
      scriptSrc: ["'self'", "'unsafe-inline'"],
      styleSrc: ["'self'", "'unsafe-inline'"],
      imgSrc: ["'self'", "data:", "https:"],
      connectSrc: ["'self'"],
      fontSrc: ["'self'"],
      objectSrc: ["'none'"],
      mediaSrc: ["'self'"],
      frameSrc: ["'none'"],
    },
  },
  crossOriginEmbedderPolicy: false,
});

// Additional XSS protection
export const xssProtection = (req: Request, res: Response, next: NextFunction) => {
  res.setHeader('X-XSS-Protection', '1; mode=block');
  res.setHeader('X-Content-Type-Options', 'nosniff');
  res.setHeader('X-Frame-Options', 'DENY');
  next();
};
```

## Encryption and Hashing

### Data Encryption
```typescript
// lib/encryption.ts
import crypto from 'crypto';

const ENCRYPTION_KEY = process.env.ENCRYPTION_KEY!; // 32 bytes key
const ALGORITHM = 'aes-256-gcm';

export const encrypt = (text: string): { encrypted: string; iv: string; tag: string } => {
  const iv = crypto.randomBytes(16);
  const cipher = crypto.createCipher(ALGORITHM, ENCRYPTION_KEY);
  
  let encrypted = cipher.update(text, 'utf8', 'hex');
  encrypted += cipher.final('hex');
  
  const tag = cipher.getAuthTag();
  
  return {
    encrypted,
    iv: iv.toString('hex'),
    tag: tag.toString('hex')
  };
};

export const decrypt = (data: { encrypted: string; iv: string; tag: string }): string => {
  const decipher = crypto.createDecipher(ALGORITHM, ENCRYPTION_KEY);
  decipher.setAuthTag(Buffer.from(data.tag, 'hex'));
  
  let decrypted = decipher.update(data.encrypted, 'hex', 'utf8');
  decrypted += decipher.final('utf8');
  
  return decrypted;
};

// For sensitive data in database
export const hashSensitiveData = (data: string): string => {
  return crypto.createHmac('sha256', ENCRYPTION_KEY)
    .update(data)
    .digest('hex');
};
```

### API Key Management
```typescript
// lib/auth/apiKeys.ts
import crypto from 'crypto';
import { db } from '../database';
import { apiKeys } from '../schemas/apiKeys';

export interface APIKey {
  id: string;
  name: string;
  keyHash: string;
  permissions: string[];
  lastUsed?: Date;
  expiresAt?: Date;
}

export const generateAPIKey = async (
  name: string,
  permissions: string[],
  expiresAt?: Date
): Promise<{ key: string; keyRecord: APIKey }> => {
  // Generate random key
  const key = `ak_${crypto.randomBytes(32).toString('hex')}`;
  const keyHash = crypto.createHash('sha256').update(key).digest('hex');
  
  // Store hash in database
  const [keyRecord] = await db
    .insert(apiKeys)
    .values({
      name,
      keyHash,
      permissions,
      expiresAt,
      createdAt: new Date()
    })
    .returning();
  
  return { key, keyRecord };
};

export const validateAPIKey = async (key: string): Promise<APIKey | null> => {
  const keyHash = crypto.createHash('sha256').update(key).digest('hex');
  
  const [apiKey] = await db
    .select()
    .from(apiKeys)
    .where(eq(apiKeys.keyHash, keyHash))
    .where(isNull(apiKeys.deletedAt));
  
  if (!apiKey) return null;
  
  // Check expiration
  if (apiKey.expiresAt && apiKey.expiresAt < new Date()) {
    return null;
  }
  
  // Update last used
  await db
    .update(apiKeys)
    .set({ lastUsed: new Date() })
    .where(eq(apiKeys.id, apiKey.id));
  
  return apiKey;
};
```

## Security Monitoring

### Audit Logging
```typescript
// lib/audit/logger.ts
export interface AuditEvent {
  userId?: string;
  action: string;
  resource: string;
  resourceId?: string;
  metadata?: Record<string, any>;
  ipAddress?: string;
  userAgent?: string;
  timestamp: Date;
  success: boolean;
}

export class AuditLogger {
  static async log(event: AuditEvent) {
    try {
      await db.insert(auditLogs).values(event);
      
      // Also log to external service if configured
      if (process.env.AUDIT_WEBHOOK_URL) {
        await fetch(process.env.AUDIT_WEBHOOK_URL, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(event)
        });
      }
    } catch (error) {
      console.error('Failed to log audit event:', error);
    }
  }

  static async logAuthEvent(
    action: 'login' | 'logout' | 'failed_login',
    userId: string,
    req: Request,
    success: boolean = true
  ) {
    await this.log({
      userId,
      action,
      resource: 'authentication',
      ipAddress: req.ip,
      userAgent: req.headers['user-agent'],
      timestamp: new Date(),
      success
    });
  }

  static async logDataAccess(
    action: 'read' | 'create' | 'update' | 'delete',
    resource: string,
    resourceId: string,
    userId: string,
    req: Request
  ) {
    await this.log({
      userId,
      action,
      resource,
      resourceId,
      ipAddress: req.ip,
      userAgent: req.headers['user-agent'],
      timestamp: new Date(),
      success: true
    });
  }
}
```

### Security Middleware
```typescript
// middleware/security.ts
export const securityMonitoring = (req: Request, res: Response, next: NextFunction) => {
  // Log suspicious activity
  const suspiciousPatterns = [
    /(\<script\>|\<\/script\>)/gi, // XSS attempts
    /(union|select|insert|delete|update|drop)/gi, // SQL injection attempts
    /(\.\./){2,}/g, // Path traversal attempts
  ];

  const requestData = JSON.stringify({
    url: req.url,
    body: req.body,
    query: req.query,
    headers: req.headers
  });

  const isSuspicious = suspiciousPatterns.some(pattern => 
    pattern.test(requestData)
  );

  if (isSuspicious) {
    console.warn('Suspicious request detected:', {
      ip: req.ip,
      url: req.url,
      userAgent: req.headers['user-agent'],
      timestamp: new Date()
    });
    
    // Could also block or rate limit here
  }

  next();
};
```

## Environment Security

### Environment Variable Validation
```typescript
// config/env.ts
import { z } from 'zod';

const EnvSchema = z.object({
  NODE_ENV: z.enum(['development', 'staging', 'production']),
  PORT: z.string().transform(Number),
  
  // Database
  DATABASE_URL: z.string().url(),
  
  // Authentication
  JWT_SECRET: z.string().min(32),
  JWT_EXPIRES_IN: z.string().default('7d'),
  ENCRYPTION_KEY: z.string().length(64), // 32 bytes in hex
  
  // External APIs
  API_BASE_URL: z.string().url(),
  
  // Security
  ALLOWED_ORIGINS: z.string().transform(str => str.split(',')),
  RATE_LIMIT_WINDOW: z.string().transform(Number).default(900000), // 15 minutes
  RATE_LIMIT_MAX: z.string().transform(Number).default(100),
});

export const env = EnvSchema.parse(process.env);

// Validate on startup
const validateEnvironment = () => {
  try {
    EnvSchema.parse(process.env);
    console.log('✅ Environment variables validated');
  } catch (error) {
    console.error('❌ Invalid environment variables:', error);
    process.exit(1);
  }
};

validateEnvironment();
```

### Secrets Management
```typescript
// lib/secrets.ts
export class SecretsManager {
  private static cache = new Map<string, { value: string; expires: number }>();

  static async getSecret(key: string): Promise<string | null> {
    // Check cache first
    const cached = this.cache.get(key);
    if (cached && cached.expires > Date.now()) {
      return cached.value;
    }

    try {
      // In production, use AWS Secrets Manager, Azure Key Vault, etc.
      let value: string | null = null;

      if (process.env.NODE_ENV === 'production') {
        // Example: AWS Secrets Manager
        // value = await this.getFromAWSSecretsManager(key);
      }

      // Fallback to environment variables
      value = value || process.env[key] || null;

      if (value) {
        // Cache for 5 minutes
        this.cache.set(key, {
          value,
          expires: Date.now() + 5 * 60 * 1000
        });
      }

      return value;
    } catch (error) {
      console.error(`Failed to retrieve secret ${key}:`, error);
      return null;
    }
  }

  static clearCache() {
    this.cache.clear();
  }
}
```

## Testing Security

### Security Test Patterns
```typescript
// tests/security/auth.test.ts
import request from 'supertest';
import { app } from '../../src/app';

describe('Authentication Security', () => {
  describe('JWT Token Security', () => {
    it('should reject malformed tokens', async () => {
      await request(app)
        .get('/api/v1/users')
        .set('Authorization', 'Bearer invalid-token')
        .expect(401);
    });

    it('should reject expired tokens', async () => {
      const expiredToken = 'eyJ...'; // Create expired token
      
      await request(app)
        .get('/api/v1/users')
        .set('Authorization', `Bearer ${expiredToken}`)
        .expect(401);
    });

    it('should reject tokens with invalid signatures', async () => {
      const tamperedToken = 'eyJ...'; // Create tampered token
      
      await request(app)
        .get('/api/v1/users')
        .set('Authorization', `Bearer ${tamperedToken}`)
        .expect(401);
    });
  });

  describe('Rate Limiting', () => {
    it('should enforce rate limits on auth endpoints', async () => {
      const loginData = { email: 'test@example.com', password: 'wrong' };

      // Make multiple failed attempts
      for (let i = 0; i < 6; i++) {
        await request(app)
          .post('/api/v1/auth/login')
          .send(loginData);
      }

      // Next request should be rate limited
      const response = await request(app)
        .post('/api/v1/auth/login')
        .send(loginData)
        .expect(429);

      expect(response.body.code).toBe('RATE_LIMITED');
    });
  });

  describe('Input Validation', () => {
    it('should sanitize XSS attempts', async () => {
      const xssPayload = {
        name: '<script>alert("xss")</script>',
        email: 'test@example.com'
      };

      const response = await request(app)
        .post('/api/v1/users')
        .set('Authorization', 'Bearer valid-admin-token')
        .send(xssPayload)
        .expect(201);

      expect(response.body.data.name).not.toContain('<script>');
    });

    it('should prevent SQL injection attempts', async () => {
      const sqlInjection = "'; DROP TABLE users; --";

      await request(app)
        .get(`/api/v1/users/${sqlInjection}`)
        .set('Authorization', 'Bearer valid-token')
        .expect(422);
    });
  });
});
```

## Security Checklist

### Development Phase
- [ ] All user inputs validated and sanitized
- [ ] Parameterized queries used for database access
- [ ] Authentication required for protected endpoints
- [ ] Authorization checks implemented for resources
- [ ] Secrets stored securely (not in code)
- [ ] HTTPS enforced in production
- [ ] Security headers configured
- [ ] Rate limiting implemented
- [ ] Error messages don't leak sensitive information

### Pre-Production
- [ ] Security scanning completed
- [ ] Penetration testing performed
- [ ] Dependencies audited for vulnerabilities
- [ ] Environment variables validated
- [ ] Backup and recovery procedures tested
- [ ] Monitoring and alerting configured
- [ ] Audit logging implemented

### Production Monitoring
- [ ] Failed authentication attempts monitored
- [ ] Unusual API usage patterns detected
- [ ] Error rates and response times tracked
- [ ] Security logs reviewed regularly
- [ ] Incident response procedures documented

## Security Resources

### Tools and Libraries
- **Authentication**: jsonwebtoken, passport
- **Password Hashing**: bcrypt, argon2
- **Input Validation**: zod, joi
- **Rate Limiting**: express-rate-limit
- **Security Headers**: helmet
- **CSRF Protection**: csurf
- **SQL Injection Prevention**: Use ORM with parameterized queries

### External Services
- **Secrets Management**: AWS Secrets Manager, Azure Key Vault, HashiCorp Vault
- **Security Scanning**: Snyk, OWASP ZAP, SonarQube
- **Monitoring**: DataDog, New Relic, Sentry
- **WAF**: Cloudflare, AWS WAF
{% endblock %}
